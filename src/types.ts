export type OptionHandler<T = any> = (provided: string, previousValue?: T) => T;
/**
 * @example "--some-option"
 * @example "-s"
 */
type OptionString = `-${string}`;
export type OptionSpec = {
  names: [OptionString, ...OptionString[]];
  description: string;
  handler: OptionHandler;
  required?: true;
};
export type Options = {
  [optionName: string]: OptionSpec;
};
type OptReturnType<T extends OptionSpec> = T["required"] extends true
  ? ReturnType<T["handler"]>
  : ReturnType<T["handler"]> | undefined;

/**
 * Unary version of `OptionstoParams` that causes less errors in index.ts
 * TODO: figure out why is that as results are supposed to be identical
 */
export type OptionsToParams<T extends Options> = {
  [K in keyof T]: OptReturnType<T[K]>;
} & { _: string[] };

type AllOptionsToParams<
  CmdOpts extends Options | void,
  GlobOpts extends Options | void,
> = { _: string[] } & (CmdOpts extends Options
  ? GlobOpts extends Options
    ? {
        [K in keyof GlobOpts | keyof CmdOpts]: K extends keyof CmdOpts
          ? OptReturnType<CmdOpts[K]>
          : K extends keyof GlobOpts
          ? OptReturnType<GlobOpts[K]>
          : never;
      }
    : { [K in keyof CmdOpts]: OptReturnType<CmdOpts[K]> }
  : GlobOpts extends Options
  ? { [K in keyof GlobOpts]: OptReturnType<GlobOpts[K]> }
  : { [key: string]: never });

/** Usage is always `cmd [...options] [...values]` */
export type CommandSpec<
  O extends Options | void,
  GO extends Options | void = void,
> = {
  /** Used in autogenerated help */
  description: string;
  /** Other names that be used yo invoke this command */
  aliases?: string[];
  /** Flags acceptable by this command and all subcommands */
  options?: O;
  /**
   * If set user must provide inline aguments, throws otherwise
   * @example "task" for a simple argument
   * @example ["paths"] for a multiple arguments
   */
  reqArgName?: string | [string];
  handler: (params: AllOptionsToParams<O, GO>) => void | Promise<void>;
};

export type ProgramSpec<T extends Options> = {
  /** Used in help and sample usage */
  name: string;
  /** Flags can be used for all sub commands */
  options: T;
  /** Used in generated help */
  description: string;
  /**
   * If specified, the cli will call it without checking for subcommands
   * Otherwise, a help with usage examples is printed
   */
  handler?: (params: OptionsToParams<T>) => void | Promise<void>;
};
